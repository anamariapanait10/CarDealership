<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>spec2chat</title>
  <link rel="stylesheet" href="./static/style.css">
  <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
</head>
<body>
  <div class="chat-wrapper">
    <div class="status-bar">
      <span class="time">12:00</span>
      <div class="status-icons">
        <span>üì∂</span>
        <span>üì°</span>
        <span>üîã</span>
      </div>
    </div>

    <div class="chat-header">
      <img src="./static/bot2.png" alt="Avatar" class="avatar">
      <div class="chat-title">
        <h2>Chat-PPT</h2>
        <p>Your favourite assistant</p>
      </div>
    </div>

    <div class="chat-view" id="chat-view">
      <div class="bot-container">
        <div class="bot-msg">Hello! Want some help?</div>
      </div>
    </div>

    <div class="input-section">
      <input type="text" id="my-text" placeholder="Type your message...">
      <button class="send" id="send-btn">‚û§</button>
    </div>
  </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script src="https://smtpjs.com/smtp.js"></script>
    <script>
        let arrayAnswer = [];
        let arrayQuestions = [];
        let questionsDict = {};
        let filledParams = {};
        let questionKey = "";
        let service_id = "";
        let user_intent = "";
        let turnCount = 0;
        let userInput = "";
        let initialInputCaptured = false;
        let userEmail = "";
        let services = [];
        let awaitingResponse = false;

        // Nueva variable global para almacenar datos del servidor
        let serverData = {
            intent: '',
            filledslots: {},
            userinput: '',
            useranswers: [],
            email: '',
            service_id: '',
            services: [],
            domain: '',
            reqslots: [],
            tasks: {},
            final: false
        };

        let jwtToken = "";

        async function loginAndGetToken() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username: 'admin', password: 'admin123' })
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const data = await response.json();
                jwtToken = data.access_token;
                console.log("JWT obtenido:", jwtToken);
            } catch (error) {
                console.error('Error obteniendo el token JWT:', error);
            }
        }

        // Funci√≥n para mostrar mensajes de error
        function showErrorMessage(message) {
            let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + message + '</p></div></div>';
            $(".chat-view").append(botBubble);
        }

        async function handleNextStep() {
            console.log("ENTRO EN HANDLENEXTSTEP CON TOURNCOUNT:", turnCount);
            console.log("awaitingResponse es:", awaitingResponse);

            if (awaitingResponse) {
                console.log("Bloqueado porque awaitingResponse est√° en true");
                return;
            }

            if (!jwtToken) await loginAndGetToken();

            const requestData = {
                intent: serverData.intent || '',
                filledslots: serverData.filledslots || {},
                userinput: serverData.userinput || '',
                useranswers: serverData.useranswers || [],
                email: serverData.email || '',
                service_id: serverData.service_id || '',
                services: serverData.services || [],
                domain: serverData.domain || '',
                reqslots: serverData.reqslots || [],
                tasks: serverData.tasks || {},
                final: serverData.final || false
            };

            // Agregar depuraci√≥n para ver el estado de los servicios
            console.log("Estado de services antes de la llamada:", serverData.services);
            console.log("Preparando requestData para la siguiente llamada:", requestData);

            try {
                awaitingResponse = true;  // Bloqueamos nuevas interacciones solo antes de las llamadas
                console.log("awaitingResponse se pone en true antes de llamada as√≠ncrona");

                if (serverData.domain === 'out-of-domain') {
                    console.log('Dominio detectado como out-of-domain. Llamada a /chatbot para manejar dominio abierto.');
                    await getInitialQuestions(requestData);
                } else {
                    // Continuamos el flujo del chatbot
                    await sendUserDataToServer(requestData);
                }
            } catch (error) {
                console.error('Error en handleNextStep:', error);
                showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
            } finally {
                awaitingResponse = false; // Restablecemos awaitingResponse
            }
        }

        async function getInitialQuestions(requestData) {
            console.log("Entrando en getInitialQuestions");

            try {
                console.log('Llamada a /chatbot con turnCount:', turnCount);

                const response = await fetch('http://139.59.175.111:5000/chatbot', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ${jwtToken}'
                    },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const data = await response.json();
                console.log('Datos recibidos de /chatbot:', data);

                // Aqu√≠ verificamos si se recibi√≥ la se√±al de fin de conversaci√≥n
                if (data.end_of_conversation === true) {
                    console.log("FINAL DE CONVERSACI√ìN DETECTADO");
                    showFinalMessage(data.chatbot_answer || "Thank you! The conversation has ended.");
                    resetConversationState(); // Reiniciar todo cuando se acaba la conversaci√≥n
                    return; // Salimos de la funci√≥n
                }

                // Manejar caso de dominio abierto
                if (data.dom === "out-of-domain") {
                    console.log("Dominio fuera de los conocidos. Modo di√°logo abierto activado.");
                    serverData.domain = "out-of-domain";
                    await processOpenDomainConversation(data);
                }

                // Aqu√≠ inicializamos serverData con los datos recibidos del servidor
                serverData.final = data.final || false;
                serverData.intent = data.intent || '';
                serverData.userinput = data.userinput || '';

                if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
                    serverData.useranswers = data.useranswers;
                }

                serverData.email = data.email || '';
                serverData.service_id = data.service_id || '';
                serverData.services = Array.isArray(data.services) ? data.services : [];
                serverData.domain = data.dom || '';
                serverData.reqslots = Array.isArray(data.reqslots) ? data.reqslots : [];
                serverData.tasks = data.tasks || {};
                serverData.filledslots = data.filledslots || {};

                // Actualizamos los 'filledSlots' con las respuestas del usuario, si hay valores
                Object.keys(data.filledslots || {}).forEach(function (key) {
                    if (data.filledslots[key] && data.filledslots[key] !== "") {
                        // Solo actualizamos los slots llenos, no sobrescribimos todo filledSlots
                        serverData.filledslots[key] = data.filledslots[key];
                    }
                });

                // Primero procesar las preguntas, si existen
                if (data.questions && Object.keys(data.questions).length > 0) {
                    console.log("awaitingresponse1:", awaitingResponse);
                    await processQuestionsData(data);  // Procesar preguntas si existen
                    awaitingResponse = true; // Se debe esperar a que el usuario responda
                }
                console.log("awaitingresponse2:", awaitingResponse);

                // Luego verificar si es la interacci√≥n final
                if (data.final === true && !awaitingResponse) {
                    console.log("Procesando el final de la tarea actual");

                    // Solo ahora limpiar filledSlots porque finalizamos un dominio
                    clearServerData();

                    // Si hay m√°s tareas (otros dominios), continuar con la siguiente interacci√≥n
                    if (Object.keys(data.tasks).length > 0) {
                        serverData.tasks = data.tasks || {}; // Actualiza las nuevas tareas
                        await handleNextStep();  // Pasar a la siguiente tarea
                    } else {
                        // Si no hay m√°s tareas, mostrar un mensaje de finalizaci√≥n
                        showFinalMessage("All tasks completed!");
                        resetConversationState(); // Reinicia todo al completar todas las tareas
                    }
                }
            } catch (error) {
                console.error('Error en llamada a /chatbot:', error);
                showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
            }
        }

        async function processOpenDomainConversation(data) {
            let chatbot_answer = data.chatbot_answer || "No se recibi√≥ respuesta del servidor.";
            let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + chatbot_answer + '</p></div></div>';
            $(".chat-view").append(botBubble);
            $(".chat-view").stop().animate({ scrollTop: $(".chat-view")[0].scrollHeight }, 1000);

            // Aseg√∫rate de no duplicar interacciones; solo actualiza el historial con los datos del servidor
            if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
                serverData.useranswers = data.useranswers;
            }

            console.log("Dominio fuera de los conocidos, esperando nuevas interacciones del usuario.");

            awaitingResponse = false;  // Restablecemos awaitingResponse para permitir una nueva interacci√≥n
        }

        async function processQuestionsData(data) {
            console.log("awaitingresponse3:", awaitingResponse);
            if (data["questions"] && typeof data["questions"] === 'object') {
                arrayQuestions = Object.values(data["questions"]).filter(val => val !== '');
                questionsDict = data["questions"];
            }

            if (data["filled"] && typeof data["filled"] === 'object') {
                Object.keys(data["filled"]).forEach(function (key) {
                    if (data["filled"][key] && data["filled"][key] !== "") {
                        serverData.filledslots[key] = data["filled"][key];
                    }
                });
            }

            if (arrayQuestions.length > 0) {
                questionKey = Object.keys(questionsDict)[0];
                showQuestion(0);
                console.log("awaitingresponse4:", awaitingResponse);
            }
        }

        function showQuestion(number) {
            if (number < arrayQuestions.length) {
                let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + arrayQuestions[number] + '</p></div></div>';
                $(".chat-view").append(botBubble);
                $(".chat-view").stop().animate({ scrollTop: $(".chat-view")[0].scrollHeight }, 1000);
                awaitingResponse = true;  // Bloqueamos nuevas respuestas autom√°ticas hasta que el usuario responda
            }
        }

        async function sendUserDataToServer(requestData) {
            console.log("Enviando datos del usuario al servidor: ", requestData);

            try {
                const response = await fetch('/chatbot', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const data = await response.json();
                console.log('Datos recibidos de /chatbot desde Senduserdatatoserver:', data);
                console.log('end_of_conversation es:', data.end_of_conversation);

                // Aqu√≠ inicializamos serverData con los datos recibidos del servidor
                serverData.final = data.final || false;
                serverData.intent = data.intent || '';
                serverData.userinput = data.userinput || '';

                if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
                    serverData.useranswers = data.useranswers;
                }

                serverData.email = data.email || '';
                serverData.service_id = data.service_id || '';
                serverData.services = Array.isArray(data.services) ? data.services : [];
                serverData.domain = data.dom || '';
                serverData.reqslots = Array.isArray(data.reqslots) ? data.reqslots : [];
                serverData.tasks = data.tasks || {};
                serverData.filledslots = data.filledslots || {};

                if (data.end_of_conversation) {
                    console.log("FINAL DE CONVERSACI√ìN");
                    showFinalMessage("Thank you! The conversation has ended.");
                    resetConversationState(); // Reiniciar todo cuando se acaba la conversaci√≥n
                    return;
                }

                // Manejar caso de dominio abierto
                if (data.dom === "out-of-domain") {
                    console.log("Dominio fuera de los conocidos. Modo di√°logo abierto activado.");
                    serverData.domain = "out-of-domain";
                    await processOpenDomainConversation(data);
                }

                if (data.final === true && !awaitingResponse) {
                    console.log("Procesando el final de la tarea actual");

                    // Limpieza del estado actual de las preguntas y respuestas del usuario
                    clearCurrentInteraction();

                    // Reiniciar serverData para la nueva tarea
                    clearServerData(); // Llama a una funci√≥n que limpia serverData

                    // Continuar la conversaci√≥n
                    await handleNextStep();
                } else {
                    // Si no es final, continuar con el flujo normal
                    await processQuestionsData(data);
                    turnCount++;
                }
            } catch (error) {
                console.error('Error en llamada a /chatbot:', error);
                showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
            }
        }

        function clearCurrentInteraction() {
            console.log("Limpiando interacci√≥n actual...");

            // Limpiar las variables de la interacci√≥n actual
            //arrayAnswer = [];
            arrayQuestions = [];
            questionsDict = {};
            questionKey = "";
            service_id = "";
            //user_intent = "";
            turnCount = 0;
            //initialInputCaptured = false;
            awaitingResponse = false;
            userAnswers = [];

            // Limpiar los datos de la interacci√≥n en serverData
            //serverData.filledslots = {};
            serverData.useranswers = [];
        }

        function clearServerData() {
            console.log("Limpiando serverData para el siguiente dominio...");

            // Mant√©n las tareas y el intent actual si cambia de dominio
            const tasks = serverData.tasks;  // Mant√©n las tareas activas
            const domain = serverData.domain; // Mant√©n el intent activo
            const userinput = serverData.userinput;
            const intent = serverData.intent;

            serverData = {
                intent: intent,  // No limpiar el intent si sigue siendo relevante
                filledslots: {},
                userinput: userinput,
                useranswers: [],
                service_id: '',
                services: [],
                domain: domain,
                reqslots: [],
                tasks: tasks,  // Mant√©n las tareas
                final: false
            };
        }

        // Funci√≥n que maneja cuando el usuario responde una pregunta
        $("#my-text").keypress(async function (e) {
            console.log("Awaitingresponse en intro es:", awaitingResponse);
            if (e.which == 13 && !awaitingResponse) {  // Solo procesamos la tecla Enter si awaitingResponse es false
                console.log("Procesando tecla Enter.");

                e.preventDefault();
                let myText = $("#my-text").val().trim();
                if (myText === "") return;  // No hacer nada si la entrada est√° vac√≠a

                let userBubble = '<div class="user-container"><div class="user-msg">' + myText + '</div></div>';
                $("#my-text").val("");
                $(".chat-view").append(userBubble);
                $(".chat-view").stop().animate({ scrollTop: $(".chat-view")[0].scrollHeight }, 1000);

                // Si es la primera interacci√≥n, iniciamos el flujo
                if (!initialInputCaptured) {
                    console.log("Iniciando flujo de conversaci√≥n con la primera interacci√≥n.");
                    serverData.userinput = myText;  // Guardamos el input inicial
                    initialInputCaptured = true;  // Marcamos que el input inicial ya fue capturado
                    awaitingResponse = false;  // Restablecemos awaitingResponse
                    await handleNextStep();  // Llamamos al siguiente paso
                    return;
                }

                if (serverData.domain === 'out-of-domain') {
                    console.log("Modo 'out-of-domain'. Procesando nueva interacci√≥n.");
                    serverData.userinput = myText;  // Guardamos la nueva entrada
                    awaitingResponse = false;  // Restablecemos awaitingResponse
                    await handleNextStep();  // Volvemos a llamar a `handleNextStep`
                    return;
                }

                // Si estamos procesando una respuesta a una pregunta
                if (questionKey && myText !== "") {
                    awaitingResponse = true;  // Bloqueamos nuevas respuestas hasta que se procese la respuesta actual
                    // Agregar la respuesta al slot correspondiente
                    serverData.filledslots[questionKey] = myText;  // Aqu√≠ mantenemos los slots previos

                    arrayAnswer.push({ chatbot: questionsDict[questionKey], user: myText });
                    serverData.useranswers.push({ chatbot: questionsDict[questionKey], user: myText });

                    delete questionsDict[questionKey];  // Eliminar la pregunta contestada
                    arrayQuestions.shift();  // Eliminar la primera pregunta

                    // Si hay m√°s preguntas, las mostramos
                    if (arrayQuestions.length > 0) {
                        questionKey = Object.keys(questionsDict)[0];  // Actualizamos la clave para la siguiente pregunta
                        showQuestion(0);  // Mostramos la siguiente pregunta
                        awaitingResponse = false;
                    } else {
                        console.log("No hay m√°s preguntas, llamando a handleNextStep.");
                        console.log("Datos del servidor:", serverData);
                        awaitingResponse = false;  // Restablecemos awaitingResponse para permitir al usuario responder nuevamente
                        await handleNextStep();  // Llamamos al siguiente paso
                    }
                }
            }
        });

        function showFinalMessage(chatbotAnswer = null) {
            let finalMessage = chatbotAnswer || "Thank you! Your request will be processed. Goodbye!";
            let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + finalMessage + '</p></div></div>';
            $(".chat-view").append(botBubble);
        }

        function resetConversationState() {
            arrayAnswer = [];
            arrayQuestions = [];
            questionsDict = {};
            filledParams = {};
            questionKey = "";
            service_id = "";
            user_intent = "";
            turnCount = 0;
            userInput = "";
            initialInputCaptured = false;
            userEmail = "";
            services = [];
            awaitingResponse = false;

            // Reiniciar tambi√©n el objeto serverData
            serverData = {
                intent: '',
                filledslots: {},
                userinput: '',
                useranswers: [],
                email: '',
                service: '',
                services: [],
                domain: '',
                reqslots: [],
                tasks: {}
            };
        }
    </script>

</body>
</html>