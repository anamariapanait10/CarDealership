<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>spec2chat</title>
    <link rel="stylesheet" href="./static/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
</head>
<body>
<a href="/database" class="button">View database data</a>
<div class="container">

    <div class="page-header">
        <h1>ðŸš— Dealership Assistant</h1>
        <p>Virtual assistant for the car dealership</p>
    </div>

    <div class="chat-container">
        <div class="chat-header">
            <h2>ðŸ’¬ Chat with the assistant</h2>
        </div>

        <div class="chat-view chat-messages" id="chat-view">
            <div class="bot-container">
                <div class="bot-msg message bot">
                    Hi! I am the dealership virtual assistant. How can I help you today? I can assist with test-drive bookings, car information, financing applications or used car trade-ins.
                </div>
            </div>
        </div>

        <div class="input-section chat-input-container">
            <input
                    type="text"
                    id="my-text"
                    class="chat-input"
                    placeholder="Type your message here..."
            />
            <button class="send send-button" id="send-btn">Send</button>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-card">
            <h3>ðŸ“‹ Available Services</h3>
            <ul>
                <li>Test drive scheduling</li>
                <li>Trade in quotes</li>
                <li>Request vehicle information</li>
                <li>Financing application</li>
            </ul>
        </div>

        <div class="info-card">
            <h3>âš¡ Tips</h3>
            <ul>
                <li>Be specific (date, car brand, model)</li>
                <li>Include contact details when asked</li>
            </ul>
        </div>
    </div>
</div>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
    let arrayAnswer = [];
    let arrayQuestions = [];
    let questionsDict = {};
    let filledParams = {};
    let questionKey = "";
    let service_id = "";
    let user_intent = "";
    let turnCount = 0;
    let userInput = "";
    let initialInputCaptured = false;
    let userEmail = "";
    let services = [];
    let awaitingResponse = false;

    let serverData = {
        intent: '',
        filledslots: {},
        userinput: '',
        useranswers: [],
        email: '',
        service_id: '',
        services: [],
        domain: '',
        reqslots: [],
        tasks: {},
        final: false
    };

    let jwtToken = "";

    async function loginAndGetToken() {
        try {
            const response = await fetch(`${API_BASE_URL}/api/login`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({username: 'admin', password: 'admin123'})
            });

            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

            const data = await response.json();
            jwtToken = data.access_token;
            console.log("JWT obtenido:", jwtToken);
        } catch (error) {
            console.error('Error obteniendo el token JWT:', error);
        }
    }

    function showErrorMessage(message) {
        let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + message + '</p></div></div>';
        $(".chat-view").append(botBubble);
    }

    async function handleNextStep() {
        console.log("ENTRO EN HANDLENEXTSTEP CON TOURNCOUNT:", turnCount);
        console.log("awaitingResponse es:", awaitingResponse);

        if (awaitingResponse) {
            console.log("Bloqueado porque awaitingResponse estÃ¡ en true");
            return;
        }

        if (!jwtToken) await loginAndGetToken();

        const requestData = {
            intent: serverData.intent || '',
            filledslots: serverData.filledslots || {},
            userinput: serverData.userinput || '',
            useranswers: serverData.useranswers || [],
            email: serverData.email || '',
            service_id: serverData.service_id || '',
            services: serverData.services || [],
            domain: serverData.domain || '',
            reqslots: serverData.reqslots || [],
            tasks: serverData.tasks || {},
            final: serverData.final || false
        };

        console.log("Estado de services antes de la llamada:", serverData.services);
        console.log("Preparando requestData para la siguiente llamada:", requestData);

        try {
            awaitingResponse = true;
            console.log("awaitingResponse se pone en true antes de llamada asÃ­ncrona");

            if (serverData.domain === 'out-of-domain') {
                console.log('Dominio detectado como out-of-domain. Llamada a /chatbot para manejar dominio abierto.');
                await getInitialQuestions(requestData);
            } else {
                await sendUserDataToServer(requestData);
            }
        } catch (error) {
            console.error('Error en handleNextStep:', error);
            showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
        } finally {
            awaitingResponse = false;
        }
    }

    async function getInitialQuestions(requestData) {
        console.log("Entrando en getInitialQuestions");

        try {
            console.log('Llamada a /chatbot con turnCount:', turnCount);

            const response = await fetch('http://139.59.175.111:5000/chatbot', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer ${jwtToken}'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

            const data = await response.json();
            console.log('Datos recibidos de /chatbot:', data);

            if (data.end_of_conversation === true) {
                console.log("FINAL DE CONVERSACIÃ“N DETECTADO");
                showFinalMessage(data.chatbot_answer || "Thank you! The conversation has ended.");
                resetConversationState();
                return;
            }

            if (data.dom === "out-of-domain") {
                console.log("Dominio fuera de los conocidos. Modo diÃ¡logo abierto activado.");
                serverData.domain = "out-of-domain";
                await processOpenDomainConversation(data);
            }

            serverData.final = data.final || false;
            serverData.intent = data.intent || '';
            serverData.userinput = data.userinput || '';

            if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
                serverData.useranswers = data.useranswers;
            }

            serverData.email = data.email || '';
            serverData.service_id = data.service_id || '';
            serverData.services = Array.isArray(data.services) ? data.services : [];
            serverData.domain = data.dom || '';
            serverData.reqslots = Array.isArray(data.reqslots) ? data.reqslots : [];
            serverData.tasks = data.tasks || {};
            serverData.filledslots = data.filledslots || {};

            Object.keys(data.filledslots || {}).forEach(function (key) {
                if (data.filledslots[key] && data.filledslots[key] !== "") {
                    serverData.filledslots[key] = data.filledslots[key];
                }
            });

            if (data.questions && Object.keys(data.questions).length > 0) {
                console.log("awaitingresponse1:", awaitingResponse);
                await processQuestionsData(data);
                awaitingResponse = true;
            }
            console.log("awaitingresponse2:", awaitingResponse);

            if (data.final === true && !awaitingResponse) {
                console.log("Procesando el final de la tarea actual");

                clearServerData();

                if (Object.keys(data.tasks).length > 0) {
                    serverData.tasks = data.tasks || {};
                    await handleNextStep();
                } else {
                    showFinalMessage("All tasks completed!");
                    resetConversationState();
                }
            }
        } catch (error) {
            console.error('Error en llamada a /chatbot:', error);
            showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
        }
    }

    async function processOpenDomainConversation(data) {
        let chatbot_answer = data.chatbot_answer || "No se recibiÃ³ respuesta del servidor.";
        let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + chatbot_answer + '</p></div></div>';
        $(".chat-view").append(botBubble);
        $(".chat-view").stop().animate({scrollTop: $(".chat-view")[0].scrollHeight}, 1000);

        if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
            serverData.useranswers = data.useranswers;
        }

        console.log("Dominio fuera de los conocidos, esperando nuevas interacciones del usuario.");

        awaitingResponse = false;
    }

    async function processQuestionsData(data) {
        console.log("awaitingresponse3:", awaitingResponse);
        if (data["questions"] && typeof data["questions"] === 'object') {
            arrayQuestions = Object.values(data["questions"]).filter(val => val !== '');
            questionsDict = data["questions"];
        }

        if (data["filled"] && typeof data["filled"] === 'object') {
            Object.keys(data["filled"]).forEach(function (key) {
                if (data["filled"][key] && data["filled"][key] !== "") {
                    serverData.filledslots[key] = data["filled"][key];
                }
            });
        }

        if (arrayQuestions.length > 0) {
            questionKey = Object.keys(questionsDict)[0];
            showQuestion(0);
            console.log("awaitingresponse4:", awaitingResponse);
        }
    }

    function showQuestion(number) {
        if (number < arrayQuestions.length) {
            let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + arrayQuestions[number] + '</p></div></div>';
            $(".chat-view").append(botBubble);
            $(".chat-view").stop().animate({scrollTop: $(".chat-view")[0].scrollHeight}, 1000);
            awaitingResponse = true;
        }
    }

    async function sendUserDataToServer(requestData) {
        console.log("Enviando datos del usuario al servidor: ", requestData);

        try {
            const response = await fetch('/chatbot', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(requestData)
            });

            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

            const data = await response.json();
            console.log('Datos recibidos de /chatbot desde Senduserdatatoserver:', data);
            console.log('end_of_conversation es:', data.end_of_conversation);

            serverData.final = data.final || false;
            serverData.intent = data.intent || '';
            serverData.userinput = data.userinput || '';

            if (Array.isArray(data.useranswers) && data.useranswers.length > 0) {
                serverData.useranswers = data.useranswers;
            }

            serverData.email = data.email || '';
            serverData.service_id = data.service_id || '';
            serverData.services = Array.isArray(data.services) ? data.services : [];
            serverData.domain = data.dom || '';
            serverData.reqslots = Array.isArray(data.reqslots) ? data.reqslots : [];
            serverData.tasks = data.tasks || {};
            serverData.filledslots = data.filledslots || {};

            if (data.end_of_conversation) {
                console.log("FINAL DE CONVERSACIÃ“N");
                showFinalMessage("Thank you! The conversation has ended.");
                if (data.external_api_response != null)
                    alert(data.external_api_response)
                resetConversationState();
                return;
            }

            if (data.dom === "out-of-domain") {
                console.log("Dominio fuera de los conocidos. Modo diÃ¡logo abierto activado.");
                serverData.domain = "out-of-domain";
                await processOpenDomainConversation(data);
            }

            if (data.final === true && !awaitingResponse) {
                console.log("Procesando el final de la tarea actual");

                clearCurrentInteraction();

                clearServerData();

                await handleNextStep();
            } else {
                await processQuestionsData(data);
                turnCount++;
            }
        } catch (error) {
            console.error('Error en llamada a /chatbot:', error);
            showErrorMessage("I cannot help you with that. Can you repeat the question, please?");
        }
    }

    function clearCurrentInteraction() {
        console.log("Limpiando interacciÃ³n actual...");

        arrayQuestions = [];
        questionsDict = {};
        questionKey = "";
        service_id = "";
        //user_intent = "";
        turnCount = 0;
        //initialInputCaptured = false;
        awaitingResponse = false;
        userAnswers = [];

        serverData.useranswers = [];
    }

    function clearServerData() {
        console.log("Limpiando serverData para el siguiente dominio...");

        const tasks = serverData.tasks;
        const domain = serverData.domain;
        const userinput = serverData.userinput;
        const intent = serverData.intent;

        serverData = {
            intent: intent,
            filledslots: {},
            userinput: userinput,
            useranswers: [],
            service_id: '',
            services: [],
            domain: domain,
            reqslots: [],
            tasks: tasks,
            final: false
        };
    }

    $("#my-text").keypress(async function (e) {
        console.log("Awaitingresponse en intro es:", awaitingResponse);
        if (e.which == 13 && !awaitingResponse) {
            console.log("Procesando tecla Enter.");

            e.preventDefault();
            let myText = $("#my-text").val().trim();
            if (myText === "") return;

            let userBubble = '<div class="user-container"><div class="user-msg">' + myText + '</div></div>';
            $("#my-text").val("");
            $(".chat-view").append(userBubble);
            $(".chat-view").stop().animate({scrollTop: $(".chat-view")[0].scrollHeight}, 1000);

            if (!initialInputCaptured) {
                console.log("Iniciando flujo de conversaciÃ³n con la primera interacciÃ³n.");
                serverData.userinput = myText;
                initialInputCaptured = true;
                awaitingResponse = false;
                await handleNextStep();
                return;
            }

            if (serverData.domain === 'out-of-domain') {
                console.log("Modo 'out-of-domain'. Procesando nueva interacciÃ³n.");
                serverData.userinput = myText;
                awaitingResponse = false;
                await handleNextStep();
                return;
            }

            if (questionKey && myText !== "") {
                awaitingResponse = true;
                serverData.filledslots[questionKey] = myText;

                arrayAnswer.push({chatbot: questionsDict[questionKey], user: myText});
                serverData.useranswers.push({chatbot: questionsDict[questionKey], user: myText});

                delete questionsDict[questionKey];
                arrayQuestions.shift();

                if (arrayQuestions.length > 0) {
                    questionKey = Object.keys(questionsDict)[0];
                    showQuestion(0);
                    awaitingResponse = false;
                } else {
                    console.log("No hay mÃ¡s preguntas, llamando a handleNextStep.");
                    console.log("Datos del servidor:", serverData);
                    awaitingResponse = false;
                    await handleNextStep();
                }
            }
        }
    });

    function showFinalMessage(chatbotAnswer = null) {
        let finalMessage = chatbotAnswer || "Thank you! Your request will be processed. Goodbye!";
        let botBubble = '<div class="bot-container"><div class="bot-msg"><p>' + finalMessage + '</p></div></div>';
        $(".chat-view").append(botBubble);
    }

    function resetConversationState() {
        arrayAnswer = [];
        arrayQuestions = [];
        questionsDict = {};
        filledParams = {};
        questionKey = "";
        service_id = "";
        user_intent = "";
        turnCount = 0;
        userInput = "";
        initialInputCaptured = false;
        userEmail = "";
        services = [];
        awaitingResponse = false;

        serverData = {
            intent: '',
            filledslots: {},
            userinput: '',
            useranswers: [],
            email: '',
            service: '',
            services: [],
            domain: '',
            reqslots: [],
            tasks: {}
        };
    }
</script>

</body>
</html>